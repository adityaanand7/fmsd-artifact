
## <h1 align="center"> FMSD Artifact

1. Title of the paper: "Partial Program Analysis for Staged
Compilation Systems"

2. For downloading the artifact: git clone the repo.

## Overview: Artifact contents and badges clamied

* The artifact is contained in a fmsd directory. It contains the java class files which can be used to artifact results.

  
## Artifact Requirements

We have performed our experiments on an Intel Xeon E5-2630 2.4 GHz system with 32 cores and 64 GB of RAM, running Cent OS version 7.
So for running the benchmark it is required to have similar kind of configuration, however for running the sample program it should be fine on a machine with fewer cores and lesser RAM as well.

## Getting Started

###	 1. Starting with execution 

After cloning the repository, the source code can be found in the `fmsd-artifact` directory. The directory contains four folders 
> &nbsp;&nbsp; 1. benchmarks   &nbsp;&nbsp; 2. jdk1.8.0_301 &nbsp;&nbsp; 3. StagedAnalysis &nbsp;&nbsp; 4. WholeProgramAnalysis

and four files 
> 1. staged.sh &nbsp;&nbsp; 2. wholeprogram.sh &nbsp;&nbsp; 3. LICENSE &nbsp;&nbsp; 4. README.md.` 

#### Executing the Staged Analysis:

1. Staged analysis can be performed using the ***staged.sh*** script:
	  <code> bash ./staged.sh $name</code> where name can be any of the benchmarks or a sample program:

   * For example for running a sample program present in [benchmarks/tests/mytest](benchmarks/tests/mytest) directory.  
	Command will be `$ bash staged.sh sample`

   * Similarly for running a benchmark program, like Moldyn or RayTracer from JGF benchmark suit present in the benchmarks directory at [benchmarks/jgf/Moldyn/](benchmarks/jgf/Moldyn/)
    Command will be `$ bash staged.sh moldyn` and Command will be `$ bash staged.sh raytracer`

   * Finally, for running benchmark programs from DaCapo benchmark suite present in the benchmarks directory at [benchmarks/jgf/DaCapo/](benchmarks/dacapo/)
	 Command will be `$ bash staged.sh dacapo benchmark_name` where the `benchmark_name` can be any of the benchmark programs present in the DaCapo benchmark suite.
     * For example, for running the avrora benchmark, the command will be `$ bash staged.sh dacapo avrora`
   
Staged Analysis is performed in 4 phases. The first two phases generate results for application methods and library methods, respectively. The third and the final phases generate the specialized code and the final analysis result, respectively.

##### PHASES 1 and 2 

The first two phases (1. Application Evaluation) and (2.LibraryEvaluation) comprise of three "Steps":

1. Generating the dependencies. For example, for moldyn, the file [StagedAnalysis/1.ApplicationEvaluation/0.Stava/output/CVOUT.txt](StagedAnalysis/1.ApplicationEvaluation/0.Stava/scripts/CVOUT.txt) consists of 473 dependencies (#PE in Figure 19 for moldyn in the paper). 
        
2. Prepass division of dependencies. It divides the dependencies in Static, Dynamic and Runtime categories. The prepass of library part the files in [StagedAnalysis/1.ApplicationEvaluation/1.PrePass/evalout/](StagedAnalysis/2.LibraryEvaluation/1.PrePass/evalout/) constitute the result of the division prepass over the input dependencies (Figure 14) present in the "res" folder generated by Step 1. (approx time for moldyn ~ 10 minutes)
        
3. Generating partial result for the dependencies from Step 2. For example, [StagedAnalysis/1.ApplicationEvaluation/2.Evaluator/PartialRes.txt](StagedAnalysis/1.ApplicationEvaluation/2.Evaluator/PartialRes.txt) contains the partial result generated for the application code of moldyn (Figure 19), and [StagedAnalysis/2.LibraryEvaluation/2.Evaluator/finalout/](StagedAnalysis/2.LibraryEvaluation/2.Evaluator/finalout/) consists of the partial results for the library dependencies of moldyn. (Library part takes approx time for moldyn 12 minutes)

##### PHASES 3 and 4 

The third phase generates the specialized code as a result of specializing the evaluator with the partial results, and the fourth phase executes the specialized code by supplying the partially evaluated dynamic dependencies generated in Step 3 above.
        
- The third phase generates the partial-result evaluator in [StagedAnalysis/3.Specializer/2.MixAlgo-Wrapper/output/SpecializedCode.java](StagedAnalysis/3.Specializer/2.MixAlgo-Wrapper/output/SpecializedCode.java), and generates the same analysis result more efficiently in [StagedAnalysis/4.PartialResultEvaluation/Wrapper/output/out.txt](StagedAnalysis/4.PartialResultEvaluation/Wrapper/output/out.txt) `[Expected time: 2-6 seconds]`.

**IMPORTANT REMARK**: Based on the machine used and its workload (an isolated execution is preferred), the numbers obtained for various statistics may vary a bit (due to the common unpredictability associated with running java code), but in general, would follow the trends shown in the paper.

#### Inspecting the Outputs:

Observe that each step above also lists down the file in which the corresponding result is generated. Each of these files can be inspected either using an editor, or using the `cat` command (e.g. `cat StagedAnalysis/4.PartialResultEvaluation/Evaluation/output/out.txt` contains the final output after the staged analysis).

#### For running whole-program analysis
Use the command `bash wholeprogram.sh $name` where name can be any of the `moldyn`, `raytracer` or a `sample` program. Note that the whole program analysis doesn't terminate for the DaCapo benchmarks suite.

